{"file_contents":{"README.md":{"content":"# SellAuth Discord Bot\n\nThis Discord bot is designed to help you manage your SellAuth shop directly from Discord. It includes commands for managing products, checking orders, and other administrative functions for your SellAuth store.\n\n## Getting Started\n\nTo get started with the bot, clone the repository and create a `.env` file by copying `.env.example`:\n\n`cp .env.example .env`\n\nThen fill in the variables as shown below:\n\n- `BOT_TOKEN:` Your Discord bot token, which authenticates the bot with Discord.\n- `BOT_GUILD_ID:` The ID of the Discord server (guild) where the bot will operate.\n- `BOT_USER_ID_WHITELIST:` A comma-separated list of user IDs allowed to use restricted commands (commands with the `onlyWhitelist: true` property). This restriction currently applies to all commands except \"help\", \"ping\", and \"stats\".\n- `BOT_CUSTOMER_ROLE_ID:` The ID of the Discord role that will be assigned to customers who use the `claim` command.\n- `SA_API_KEY:` Your SellAuth API key, available at your SellAuth dashboard under [Account -> API Access](https://dash.sellauth.com/api). If itâ€™s not visible, click \"Regenerate\".\n- `SA_SHOP_ID:` Your SellAuth shop ID, available at your SellAuth dashboard under [Account -> API Access](https://dash.sellauth.com/api).\n\n## Installation\n\nMake sure you have Node.js installed, then install the required packages:\n\n`npm install`\n\nRunning the Bot\n\nTo start the bot, run:\n\n`node index.js`\n\n## Development Guidelines\n\n### Contributions\nWe welcome contributions of new commands or features! Please ensure that any changes maintain code quality and respect the basic structure of the bot.\n\n### Formatting\nBefore committing, run `npm run format` to auto-format the code.\n\n## Community & Support\n\nFor help, inquiries, or to join the community, visit the [SellAuth Discord server](https://discord.sellauth.com).\n\nHappy coding!\n\n## License\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n","size_bytes":1966},"commands/balances.js":{"content":"import { EmbedBuilder, SlashCommandBuilder } from 'discord.js';\nimport { formatPrice } from '../utils/formatPrice.js';\n\nexport default {\n  data: new SlashCommandBuilder().setName('balances').setDescription('View your cryptocurrency balances.'),\n\n  onlyWhitelisted: true,\n  requiredRole: 'admin',\n\n  async execute(interaction, api) {\n    const shopId = api.shopId;\n\n    try {\n      const balances = (await api.get(`shops/${shopId}/payouts/balances`)) || [];\n\n      const embed = new EmbedBuilder()\n        .setTitle('Balances')\n        .setColor('#6571ff')\n        .setTimestamp()\n        .addFields([\n          { name: 'Bitcoin', value: `${balances.btc.btc} â‚¿ (${formatPrice(balances.btc.usd, 'USD')})` },\n          { name: 'Litecoin', value: `${balances.ltc.ltc} Å (${formatPrice(balances.ltc.usd, 'USD')})` }\n        ]);\n\n      await interaction.reply({ embeds: [embed] });\n    } catch (error) {\n      console.error('Error viewing balances:', error);\n      await interaction.reply({ content: 'Failed to view balances.', ephemeral: true });\n    }\n  }\n};\n","size_bytes":1058},"commands/couponView.js":{"content":"import { EmbedBuilder, SlashCommandBuilder } from 'discord.js';\n\nexport default {\n  data: new SlashCommandBuilder()\n    .setName('coupon-view')\n    .setDescription('View a coupon.')\n    .addStringOption((option) =>\n      option.setName('code').setDescription('The coupon code to search for').setRequired(true)\n    ),\n\n  onlyWhitelisted: true,\n  requiredRole: 'admin',\n\n  async execute(interaction, api) {\n    const shopId = api.shopId;\n    const code = interaction.options.getString('code');\n\n    try {\n      // TODO: Search by ?search parameter for the next update.\n\n      let coupons = (await api.get(`shops/${shopId}/coupons`)) || [];\n\n      const coupon = coupons.find((coupon) => coupon.code === code);\n\n      if (!coupon) {\n        await interaction.reply({ content: `No coupon found with the code: ${code}`, ephemeral: true });\n        return;\n      }\n\n      // Create an embed for the single coupon\n      const embed = new EmbedBuilder()\n        .setTitle('Coupon Details')\n        .setColor('#6571ff')\n        .setTimestamp()\n        .addFields([\n          { name: 'Code', value: coupon.code },\n          { name: 'Discount', value: coupon.type === 'percentage' ? `${coupon.discount}%` : `$${coupon.discount}` },\n          {\n            name: 'Expiration Date',\n            value: coupon.expiration_date ? new Date(coupon.expiration_date).toLocaleString() : 'No Expiration Date'\n          },\n          { name: 'Uses', value: `${coupon.uses}/${coupon.max_uses || 'âˆž'}` },\n          {\n            name: 'Allowed Emails',\n            value: coupon.allowed_emails?.length ? coupon.allowed_emails.join(', ') : 'All Emails'\n          },\n          {\n            name: 'Products',\n            value: coupon.products.length ? coupon.products.map((product) => product.name).join(', ') : 'All Products'\n          }\n        ]);\n\n      await interaction.reply({ embeds: [embed] });\n    } catch (error) {\n      console.error('Error viewing coupon:', error);\n      await interaction.reply({ content: 'Failed to view coupon.', ephemeral: true });\n    }\n  }\n};\n","size_bytes":2054},"commands/invoiceView.js":{"content":"import { EmbedBuilder, SlashCommandBuilder } from 'discord.js';\nimport { formatPrice } from '../utils/formatPrice.js';\n\nconst formatCoupon = (coupon) => {\n  if (!coupon) return 'N/A';\n\n  return `${coupon.code} (${coupon.discount}${coupon.type == 'percentage' ? '%' : coupon.type == 'fixed' ? coupon.currency : ''})`;\n};\n\nconst formatCustomFields = (customFields) => {\n  if (!customFields || Object.entries(customFields).length === 0) return 'N/A';\n\n  return Object.entries(customFields)\n    .map(([key, value]) => `${key}: \"${value}\"`)\n    .join(', ');\n};\n\nconst formatDelivered = (delivered) => {\n  if (!delivered) return 'N/A';\n\n  const data = JSON.parse(delivered);\n\n  if (Array.isArray(data)) {\n    return data.join(', ');\n  }\n\n  return delivered.toString();\n};\n\nconst formatGatewayInfo = (invoice) => {\n  switch (invoice.gateway) {\n    case 'CASHAPP':\n      return `Transaction ID: \"${invoice.cashapp_transaction_id || 'N/A'}\"`;\n    case 'STRIPE':\n      return invoice.stripe_pi_id\n        ? `[https://dashboard.stripe.com/payments/${invoice.stripe_pi_id}](https://dashboard.stripe.com/payments/${invoice.stripe_pi_id})`\n        : 'N/A';\n    case 'PAYPALFF':\n      return invoice.paypalff_note ? `Note: \"${invoice.paypalff_note}\"` : 'N/A';\n    case 'SUMUP':\n      return invoice.sumup_checkout_id ? `Checkout ID: \"${invoice.sumup_checkout_id}\"` : 'N/A';\n    case 'MOLLIE':\n      return invoice.mollie_transaction_id ? `Payment ID: \"${invoice.mollie_transaction_id}\"` : 'N/A';\n    case 'SKRILL':\n      return invoice.skrill_transaction_id ? `Transaction ID: \"${invoice.skrill_transaction_id}\"` : 'N/A';\n    default:\n      return 'N/A';\n  }\n};\n\nexport default {\n  data: new SlashCommandBuilder()\n    .setName('invoice-view')\n    .setDescription('View a invoice.')\n    .addStringOption((option) => option.setName('id').setDescription('The invoice ID to search for').setRequired(true)),\n\n  onlyWhitelisted: true,\n  requiredRole: 'admin',\n\n  async execute(interaction, api) {\n    const shopId = api.shopId;\n    const id = interaction.options.getString('id');\n\n    let invoiceId = id;\n\n    if (invoiceId.includes('-')) {\n      invoiceId = Number(id.split('-')[1]);\n    }\n\n    try {\n      let invoice = await api.get(`shops/${shopId}/invoices/${invoiceId}`);\n\n      if (!invoice) {\n        await interaction.reply({ content: `No invoice found with the id: ${id}`, ephemeral: true });\n        return;\n      }\n\n      const embed = new EmbedBuilder()\n        .setTitle('Invoice Details')\n        .setColor('#6571ff')\n        .setTimestamp()\n        .addFields([\n          { name: 'ID', value: invoice.unique_id },\n          { name: 'Status', value: invoice.status.replace(/_/g, ' ') },\n          { name: 'Product', value: invoice.product?.name || 'N/A' },\n          { name: 'Variant', value: invoice.variant?.name || 'N/A' },\n          { name: 'Price', value: formatPrice(invoice.price, invoice.currency) },\n          { name: 'Coupon', value: formatCoupon(invoice.coupon) },\n          { name: 'Email', value: invoice.email },\n          { name: 'Custom Fields', value: formatCustomFields(invoice.custom_fields) },\n          { name: 'Gateway', value: invoice.gateway },\n          { name: 'Gateway Info', value: formatGatewayInfo(invoice) },\n          { name: 'Deliverables', value: formatDelivered(invoice.delivered) },\n          { name: 'IP Address', value: invoice.ip },\n          { name: 'User Agent', value: invoice.user_agent },\n          { name: 'Created At', value: `<t:${Math.floor(new Date(invoice.created_at).getTime() / 1000)}:F>` },\n          {\n            name: 'Completed At',\n            value: invoice.completed_at ? `<t:${Math.floor(new Date(invoice.completed_at).getTime() / 1000)}:F>` : 'N/A'\n          }\n        ]);\n\n      await interaction.reply({ embeds: [embed] });\n    } catch (error) {\n      console.error('Error viewing invoice:', error);\n      await interaction.reply({ content: 'Failed to view invoice.', ephemeral: true });\n    }\n  }\n};\n","size_bytes":3959},"utils/NotWhitelistedException.js":{"content":"export class NotWhitelistedException {\n  constructor() {\n    this.message = 'You do not have permission to use this command.';\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","size_bytes":178},"commands/couponUpdate.js":{"content":"import { EmbedBuilder, SlashCommandBuilder } from 'discord.js';\n\nexport default {\n  data: new SlashCommandBuilder()\n    .setName('coupon-update')\n    .setDescription('Edit an existing coupon.')\n    .addStringOption((option) => option.setName('code').setDescription('Coupon code').setRequired(true))\n    .addBooleanOption((option) => option.setName('global').setDescription('Is the coupon global?').setRequired(false))\n    .addNumberOption((option) => option.setName('discount').setDescription('Discount amount').setRequired(false))\n    .addStringOption((option) =>\n      option\n        .setName('type')\n        .setDescription('Discount type: percentage or fixed')\n        .setRequired(false)\n        .addChoices({ name: 'Percentage', value: 'percentage' }, { name: 'Fixed', value: 'fixed' })\n    )\n    .addNumberOption((option) =>\n      option.setName('max_uses').setDescription('Maximum uses for the coupon').setRequired(false)\n    )\n    .addStringOption((option) =>\n      option.setName('expiration_date').setDescription('Expiration date (e.g., 2024-09-25T12:35:22)').setRequired(false)\n    )\n    .addStringOption((option) =>\n      option.setName('allowed_emails').setDescription('Allowed emails (comma-separated)').setRequired(false)\n    )\n    .addStringOption((option) =>\n      option.setName('products').setDescription('Applicable product IDs (comma-separated)').setRequired(false)\n    ),\n\n  onlyWhitelisted: true,\n  requiredRole: 'admin',\n\n  async execute(interaction, api) {\n    const shopId = api.shopId;\n    const code = interaction.options.getString('code');\n\n    // TODO: Add endpoint to get a single coupon by code\n\n    // Get all coupons and find the one with the provided code\n    let couponData;\n    try {\n      const coupons = await api.get(`shops/${shopId}/coupons`);\n      couponData = coupons.find((coupon) => coupon.code === code);\n    } catch (error) {\n      console.error(error);\n      return interaction.reply({ content: 'Failed to load coupons.', ephemeral: true });\n    }\n\n    // Check if the coupon was found\n    if (!couponData) {\n      return interaction.reply({ content: 'Coupon not found.', ephemeral: true });\n    }\n\n    // Update the coupon data with the provided options\n    const global = interaction.options.getBoolean('global') ?? couponData.global;\n    const discount = interaction.options.getNumber('discount') ?? couponData.discount;\n    const type = interaction.options.getString('type') ?? couponData.type;\n    const maxUses = interaction.options.getNumber('max_uses') ?? couponData.max_uses;\n    const expirationDate = interaction.options.getString('expiration_date') ?? couponData.expiration_date;\n    const allowedEmails = interaction.options.getString('allowed_emails')?.split(',') ?? couponData.allowed_emails;\n    let products = interaction.options.getString('products')?.split(',') ?? couponData.products;\n\n    // Remove products if the coupon is global\n    if (global) {\n      products = [];\n    }\n\n    // Create the updated coupon data object\n    const updatedCouponData = {\n      code,\n      global,\n      discount,\n      type,\n      max_uses: maxUses,\n      expiration_date: expirationDate,\n      allowed_emails: allowedEmails,\n      products\n    };\n\n    // Send the updated coupon data to the server\n    try {\n      await api.put(`shops/${shopId}/coupons/${couponData.id}/update`, updatedCouponData);\n\n      const embed = new EmbedBuilder()\n        .setTitle('Coupon Updated')\n        .setDescription(`Coupon \\`${code}\\` has been successfully updated.`)\n        .setColor('#6571ff')\n        .addFields(\n          { name: 'Discount', value: `${discount} (${type})`, inline: true },\n          { name: 'Global', value: global ? 'Yes' : 'No', inline: true },\n          { name: 'Max Uses', value: maxUses?.toString() ?? 'âˆž', inline: true },\n          { name: 'Expires On', value: expirationDate, inline: true }\n        );\n\n      return interaction.reply({ embeds: [embed] });\n    } catch (error) {\n      console.error(error);\n      return interaction.reply({ content: 'There was an error updating the coupon.', ephemeral: true });\n    }\n  }\n};\n","size_bytes":4095},"commands/help.js":{"content":"import { EmbedBuilder, SlashCommandBuilder } from 'discord.js';\nimport { bot } from '../index.js';\n\nexport default {\n  data: new SlashCommandBuilder().setName('help').setDescription('List of available commands'),\n  onlyWhitelisted: true,\n  requiredRole: 'staff',\n  async execute(interaction) {\n    let commands = bot.slashCommandsMap;\n\n    let helpEmbed = new EmbedBuilder()\n      .setTitle('Help')\n      .setDescription('List of available commands')\n      .setColor('#6571ff');\n\n    commands.forEach((cmd) => {\n      helpEmbed.addFields({\n        name: `**${cmd.data.name}**`,\n        value: `${cmd.data.description}`,\n        inline: true\n      });\n    });\n\n    helpEmbed.setTimestamp();\n\n    return interaction.reply({ embeds: [helpEmbed] }).catch(console.error);\n  }\n};\n","size_bytes":774},"commands/couponList.js":{"content":"import { EmbedBuilder, SlashCommandBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } from 'discord.js';\n\nconst formatCoupon = (coupon, isSingle) => {\n  const { code, type, discount, expiration_date, uses, max_uses, products } = coupon;\n\n  const valueStr = `${type === 'percentage' ? `${discount}%` : `$${discount}`}`;\n  const expirationStr = expiration_date\n    ? `Expires at ${new Date(expiration_date).toLocaleString()}`\n    : 'No Expiration Date';\n  const redeemedStr = `${uses}/${max_uses || 'âˆž'}`;\n  const allowedEmailsStr = coupon.allowed_emails?.length ? coupon.allowed_emails.join(', ') : 'All Emails';\n\n  let productStr = '';\n\n  if (global) {\n    productStr = 'All Products';\n  } else if (products.length === 0) {\n    productStr = 'No Products';\n  } else if (isSingle) {\n    productStr = products.map((product) => product.name).join(', ');\n  } else {\n    // When listing multiple coupons, only show the first 2 products\n    productStr = products\n      .slice(0, 2)\n      .map((product) => product.name)\n      .join(', ');\n    if (products.length > 2) {\n      productStr += ` and ${products.length - 2} more`;\n    }\n  }\n\n  return `**${code}**: ${valueStr} â€¢ ${expirationStr} â€¢ ${redeemedStr} â€¢ ${allowedEmailsStr} â€¢ ${productStr}`;\n};\n\nexport default {\n  data: new SlashCommandBuilder().setName('coupon-list').setDescription('List all coupons.'),\n\n  onlyWhitelisted: true,\n  requiredRole: 'admin',\n\n  async execute(interaction, api) {\n    const shopId = api.shopId;\n    const pageSize = 10; // Number of coupons per page\n    let page = 1; // Current page\n\n    try {\n      // TODO: Implement server-side pagination for the next update.\n\n      let couponsResponse = await api.get(`shops/${shopId}/coupons`);\n      \n      // Handle if API returns an object with data property or direct array\n      let coupons = Array.isArray(couponsResponse) ? couponsResponse : (couponsResponse?.data || []);\n\n      const totalPages = Math.ceil(coupons.length / pageSize);\n      const startIndex = (page - 1) * pageSize;\n      const endIndex = Math.min(startIndex + pageSize, coupons.length);\n      const currentCoupons = coupons.slice(startIndex, endIndex);\n\n      const embed = new EmbedBuilder().setTitle('Coupon List').setColor('#6571ff');\n\n      if (currentCoupons.length === 0) {\n        embed.setDescription('No coupons found.');\n      } else {\n        embed.setDescription(currentCoupons.map((coupon) => formatCoupon(coupon, false)).join('\\n'));\n        embed.setFooter({ text: `Page ${page} of ${totalPages}` });\n      }\n\n      const components = [];\n      if (totalPages > 1) {\n        const row = new ActionRowBuilder();\n        if (page > 1) {\n          row.addComponents(\n            new ButtonBuilder().setCustomId('coupon-list-prev').setLabel('Previous').setStyle(ButtonStyle.Primary)\n          );\n        }\n        if (page < totalPages) {\n          row.addComponents(\n            new ButtonBuilder().setCustomId('coupon-list-next').setLabel('Next').setStyle(ButtonStyle.Primary)\n          );\n        }\n        components.push(row);\n      }\n\n      const initialResponse = await interaction.reply({ embeds: [embed], components: components, fetchReply: true });\n\n      if (totalPages > 1) {\n        const collector = interaction.channel.createMessageComponentCollector({\n          filter: (i) => i.user.id === interaction.user.id && i.message.id === initialResponse.id,\n          time: 15000\n        });\n\n        collector.on('collect', async (i) => {\n          if (i.customId === 'coupon-list-prev') page--;\n          else if (i.customId === 'coupon-list-next') page++;\n\n          const startIndex = (page - 1) * pageSize;\n          const endIndex = Math.min(startIndex + pageSize, coupons.length);\n          const currentCoupons = coupons.slice(startIndex, endIndex);\n\n          embed.setDescription(\n            currentCoupons.length === 0\n              ? 'No coupons found.'\n              : currentCoupons.map((coupon) => formatCoupon(coupon, false)).join('\\n')\n          );\n          embed.setFooter({ text: `Page ${page} of ${totalPages}` });\n\n          const newComponents = [];\n          const row = new ActionRowBuilder();\n          if (page > 1)\n            row.addComponents(\n              new ButtonBuilder().setCustomId('coupon-list-prev').setLabel('Previous').setStyle(ButtonStyle.Primary)\n            );\n          if (page < totalPages)\n            row.addComponents(\n              new ButtonBuilder().setCustomId('coupon-list-next').setLabel('Next').setStyle(ButtonStyle.Primary)\n            );\n          if (row.components.length > 0) newComponents.push(row);\n\n          await i.update({ embeds: [embed], components: newComponents });\n        });\n\n        collector.on('end', (collected) => {\n          if (collected.size === 0) {\n            interaction.editReply({ components: [] });\n          }\n        });\n      }\n    } catch (error) {\n      console.error('Error listing coupons:', error);\n      await interaction.reply({ content: 'Failed to list coupons.', ephemeral: true });\n    }\n  }\n};\n","size_bytes":5032},"utils/checkUserIdWhitelist.js":{"content":"export async function checkUserIdWhitelist(command, interaction, config) {\n  const userId = interaction.user.id;\n  const member = interaction.member;\n\n  if (command.onlyWhitelisted) {\n    // Check if user has admin role (full access to all commands)\n    if (config.BOT_ADMIN_ROLE_ID && member.roles.cache.has(config.BOT_ADMIN_ROLE_ID)) {\n      return true;\n    }\n\n    // Check if user has staff role (limited access)\n    if (config.BOT_STAFF_ROLE_ID && member.roles.cache.has(config.BOT_STAFF_ROLE_ID)) {\n      // Staff can only use commands explicitly marked with requiredRole: 'staff'\n      // All other whitelisted commands default to admin-only\n      if (command.requiredRole === 'staff') {\n        return true;\n      }\n      return false;\n    }\n\n    // Fallback to old whitelist system (for backwards compatibility)\n    return config.BOT_USER_ID_WHITELIST.includes(userId);\n  }\n\n  return true;\n}\n","size_bytes":901},"commands/stats.js":{"content":"import { EmbedBuilder, SlashCommandBuilder } from 'discord.js';\n\nconst STAT_LABELS = {\n  products_sold: 'Products Sold',\n  total_customers: 'Total Customers',\n  feedbacks_received: 'Feedbacks Received',\n  average_rating: 'Average Rating'\n};\n\nexport default {\n  data: new SlashCommandBuilder().setName('stats').setDescription('Get shop stats.'),\n  async execute(interaction, api) {\n    const stats = await api.get(`shops/${api.shopId}/stats`).catch(console.error);\n\n    let embed = new EmbedBuilder().setTitle('Shop Stats').setColor('#6571ff');\n\n    for (const [key, value] of Object.entries(stats)) {\n      embed.addFields({\n        name: `**${STAT_LABELS[key] || key}**`,\n        value: `${Math.round(value * 100) / 100}`,\n        inline: false\n      });\n    }\n\n    embed.setTimestamp();\n\n    return interaction.reply({ embeds: [embed] }).catch(console.error);\n  }\n};\n","size_bytes":869},"classes/Api.js":{"content":"import fetch from 'node-fetch';\nimport { config } from '../utils/config.js';\n\nexport class Api {\n  constructor() {\n    this.baseUrl = 'https://api.sellauth.com/v1/';\n    this.apiKey = config.SA_API_KEY;\n    this.shopId = config.SA_SHOP_ID;\n  }\n\n  async get(endpoint) {\n    const response = await fetch(`${this.baseUrl}${endpoint}`, {\n      headers: { Authorization: `Bearer ${this.apiKey}` }\n    });\n\n    if (!response.ok) {\n      throw { message: 'Invalid response', response };\n    }\n\n    return await response.json();\n  }\n\n  async post(endpoint, data) {\n    const response = await fetch(`${this.baseUrl}${endpoint}`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${this.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      throw { message: 'Invalid response', response };\n    }\n\n    return await response.json();\n  }\n\n  async put(endpoint, data) {\n    const response = await fetch(`${this.baseUrl}${endpoint}`, {\n      method: 'PUT',\n      headers: {\n        Authorization: `Bearer ${this.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      throw { message: 'Invalid response', response };\n    }\n\n    return await response.json();\n  }\n\n  async delete(endpoint) {\n    const response = await fetch(`${this.baseUrl}${endpoint}`, {\n      method: 'DELETE',\n      headers: { Authorization: `Bearer ${this.apiKey}` }\n    });\n\n    if (!response.ok) {\n      throw { message: 'Invalid response', response };\n    }\n\n    return await response.json();\n  }\n}\n","size_bytes":1637},"utils/config.js":{"content":"import 'dotenv/config';\n\nlet config = {\n  BOT_TOKEN: process.env.BOT_TOKEN || '',\n  BOT_GUILD_ID: process.env.BOT_GUILD_ID || '',\n  BOT_USER_ID_WHITELIST: process.env.BOT_USER_ID_WHITELIST?.split(',') || [],\n  BOT_CUSTOMER_ROLE_ID: process.env.BOT_CUSTOMER_ROLE_ID || '',\n  BOT_STAFF_ROLE_ID: process.env.BOT_STAFF_ROLE_ID || '',\n  BOT_ADMIN_ROLE_ID: process.env.BOT_ADMIN_ROLE_ID || '',\n  SA_API_KEY: process.env.SA_API_KEY || '',\n  SA_SHOP_ID: process.env.SA_SHOP_ID || ''\n};\n\nexport { config };\n","size_bytes":498},"classes/Bot.js":{"content":"import { Collection, Events, REST, Routes } from 'discord.js';\nimport { readdirSync } from 'fs';\nimport { fileURLToPath, pathToFileURL } from 'url';\nimport { join, dirname } from 'path';\nimport { checkUserIdWhitelist } from '../utils/checkUserIdWhitelist.js';\nimport { config } from '../utils/config.js';\nimport { NotWhitelistedException } from '../utils/NotWhitelistedException.js';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nexport class Bot {\n  constructor(client, api) {\n    this.client = client;\n    this.api = api;\n\n    this.prefix = '/';\n    this.commands = new Collection();\n    this.slashCommands = [];\n    this.slashCommandsMap = new Collection();\n    this.cooldowns = new Collection();\n    this.queues = new Collection();\n\n    this.client.login(config.BOT_TOKEN);\n\n    this.client.on('ready', () => {\n      console.log(`${this.client.user.username} ready!`);\n      this.registerSlashCommands();\n    });\n\n    this.client.on('warn', (info) => console.log(info));\n    this.client.on('error', console.error);\n\n    this.onInteractionCreate();\n  }\n\n  async registerSlashCommands() {\n    const rest = new REST({ version: '9' }).setToken(config.BOT_TOKEN);\n\n    const commandFiles = readdirSync(join(__dirname, '..', 'commands')).filter((file) => !file.endsWith('.map'));\n\n    for (const file of commandFiles) {\n      const commandPath = pathToFileURL(join(__dirname, '..', 'commands', `${file}`)).href; // Convert to file:// URL\n      const command = await import(commandPath);\n\n      this.slashCommands.push(command.default.data);\n      this.slashCommandsMap.set(command.default.data.name, command.default);\n    }\n\n    if (config.BOT_GUILD_ID) {\n      await rest.put(Routes.applicationGuildCommands(this.client.user.id, config.BOT_GUILD_ID), {\n        body: this.slashCommands\n      });\n    } else {\n      await rest.put(Routes.applicationCommands(this.client.user.id), { body: this.slashCommands });\n    }\n  }\n\n  async onInteractionCreate() {\n    this.client.on(Events.InteractionCreate, async (interaction) => {\n      // Handle autocomplete interactions\n      if (interaction.isAutocomplete()) {\n        const command = this.slashCommandsMap.get(interaction.commandName);\n        if (!command || !command.autocomplete) return;\n\n        try {\n          await command.autocomplete(interaction, this.api);\n        } catch (error) {\n          console.error('Autocomplete error:', error);\n        }\n        return;\n      }\n\n      if (!interaction.isChatInputCommand()) return;\n\n      const command = this.slashCommandsMap.get(interaction.commandName);\n\n      if (!command) return;\n\n      if (!this.cooldowns.has(interaction.commandName)) {\n        this.cooldowns.set(interaction.commandName, new Collection());\n      }\n\n      const now = Date.now();\n      const timestamps = this.cooldowns.get(interaction.commandName);\n      const cooldownAmount = (command.cooldown || 1) * 1000;\n\n      const timestamp = timestamps.get(interaction.user.id);\n\n      if (timestamp) {\n        const expirationTime = timestamp + cooldownAmount;\n\n        if (now < expirationTime) {\n          const timeLeft = (expirationTime - now) / 1000;\n          return interaction.reply({\n            content: `You need to wait ${timeLeft.toFixed(1)} more second(s) before reusing the \\`${interaction.commandName}\\` command.`,\n            ephemeral: true\n          });\n        }\n      }\n\n      timestamps.set(interaction.user.id, now);\n      setTimeout(() => timestamps.delete(interaction.user.id), cooldownAmount);\n\n      try {\n        if (await checkUserIdWhitelist(command, interaction, config)) {\n          command.execute(interaction, this.api);\n        } else {\n          throw new NotWhitelistedException();\n        }\n      } catch (error) {\n        console.error(error);\n\n        if (error.message.includes('permission')) {\n          interaction.reply({ content: error.toString(), ephemeral: true }).catch(console.error);\n        } else {\n          interaction\n            .reply({ content: 'An error occurred while executing the command.', ephemeral: true })\n            .catch(console.error);\n        }\n      }\n    });\n  }\n}\n","size_bytes":4155},"index.js":{"content":"import { Client, GatewayIntentBits } from 'discord.js';\nimport { Bot } from './classes/Bot.js';\nimport { Api } from './classes/Api.js';\n\nconst api = new Api();\n\nexport const bot = new Bot(\n  new Client({\n    intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages]\n  }),\n  api\n);\n","size_bytes":292},"commands/ping.js":{"content":"import { SlashCommandBuilder } from 'discord.js';\n\nexport default {\n  data: new SlashCommandBuilder().setName('ping').setDescription('Replies with Pong!'),\n  cooldown: 10,\n  execute(interaction) {\n    interaction\n      .reply({ content: `Pong! ${Math.round(interaction.client.ws.ping)}ms`, ephemeral: true })\n      .catch(console.error);\n  }\n};\n","size_bytes":345},"commands/couponDelete.js":{"content":"import { EmbedBuilder, SlashCommandBuilder } from 'discord.js';\n\nexport default {\n  data: new SlashCommandBuilder()\n    .setName('coupon-delete')\n    .setDescription('Delete a coupon.')\n    .addStringOption((option) => option.setName('code').setDescription('Coupon code').setRequired(true)),\n\n  onlyWhitelisted: true,\n  requiredRole: 'admin',\n\n  async execute(interaction, api) {\n    const shopId = api.shopId;\n    const code = interaction.options.getString('code');\n\n    // TODO: Add endpoint to get a single coupon by code\n\n    // Get all coupons and find the one with the provided code\n    let couponData;\n    try {\n      const coupons = await api.get(`shops/${shopId}/coupons`);\n      couponData = coupons.find((coupon) => coupon.code === code);\n    } catch (error) {\n      console.error(error);\n      return interaction.reply({ content: 'Failed to load coupons.', ephemeral: true });\n    }\n\n    // Check if the coupon was found\n    if (!couponData) {\n      return interaction.reply({ content: 'Coupon not found.', ephemeral: true });\n    }\n\n    // Send the delete request to the server\n    try {\n      await api.delete(`shops/${shopId}/coupons/${couponData.id}`);\n\n      const embed = new EmbedBuilder()\n        .setTitle('Coupon Deleted')\n        .setDescription(`Coupon \\`${code}\\` has been successfully deleted.`)\n        .setColor('#6571ff');\n\n      return interaction.reply({ embeds: [embed] });\n    } catch (error) {\n      console.error(error);\n      return interaction.reply({ content: 'There was an error deleting the coupon.', ephemeral: true });\n    }\n  }\n};\n","size_bytes":1574},"commands/productStatus.js":{"content":"import { EmbedBuilder, SlashCommandBuilder } from 'discord.js';\r\n\r\n// emoji for status colors\r\nconst COLOR_EMOJIS = {\r\n  '#e74c3c': 'ðŸ”´',\r\n  '#e67e22': 'ðŸŸ ',\r\n  '#f1c40f': 'ðŸŸ¡',\r\n  '#2ecc71': 'ðŸŸ¢',\r\n  '#3498db': 'ðŸ”µ',\r\n  'null': 'âšª'\r\n};\r\n\r\nexport default {\r\n  data: new SlashCommandBuilder()\r\n    .setName('product-status')\r\n    .setDescription('Edit a product status.')\r\n    .addStringOption((option) => \r\n      option.setName('id')\r\n        .setDescription('The product ID')\r\n        .setRequired(true))\r\n    .addStringOption((option) => \r\n      option.setName('text')\r\n        .setDescription('The status text')\r\n        .setRequired(true))\r\n    .addStringOption((option) =>\r\n      option.setName('color')\r\n        .setDescription('The status color')\r\n        .setRequired(true)\r\n        .addChoices(\r\n          { name: 'ðŸ”´ Red', value: '#e74c3c' },\r\n          { name: 'ðŸŸ  Orange', value: '#e67e22' },\r\n          { name: 'ðŸŸ¡ Yellow', value: '#f1c40f' },\r\n          { name: 'ðŸŸ¢ Green', value: '#2ecc71' },\r\n          { name: 'ðŸ”µ Blue', value: '#3498db' },\r\n          { name: 'âšª Default', value: 'null' }\r\n        )),\r\n\r\n  onlyWhitelisted: true,\r\n  requiredRole: 'admin',\n\r\n  async execute(interaction, api) {\r\n    const productId = interaction.options.getString('id');\r\n    const statusText = interaction.options.getString('text');\r\n    const statusColor = interaction.options.getString('color');\r\n    \r\n    try {\r\n      await api.put(`shops/${api.shopId}/products/bulk-update/status`, {\r\n        product_ids: [productId],\r\n        status_color: statusColor === 'null' ? null : statusColor,\r\n        status_text: statusText\r\n      });\r\n\r\n      const colorEmoji = COLOR_EMOJIS[statusColor] || 'âšª';\r\n      const embed = new EmbedBuilder()\r\n        .setTitle('Product Status Updated')\r\n        .setDescription(`Status updated for product: ${productId}`)\r\n        .addFields(\r\n          { name: 'Status Text', value: statusText, inline: true },\r\n          { name: 'Status Color', value: colorEmoji, inline: true }\r\n        )\r\n        .setColor(statusColor === 'null' ? '#6571ff' : statusColor)\r\n        .setTimestamp();\r\n\r\n      return interaction.reply({ embeds: [embed] });\r\n\r\n    } catch (error) {\r\n      console.error('Error updating product status:', error);\r\n\r\n      if (error.message == 'Invalid response') {\r\n        if (error.response.status === 500) {\r\n          return interaction.reply({ \r\n            content: 'Failed to update product status. Product not found.',\r\n            ephemeral: true \r\n          });\r\n        }\r\n      }\r\n\r\n      return interaction.reply({ \r\n        content: 'Failed to update product status. Error: ' + error.message,\r\n        ephemeral: true \r\n      });\r\n    }\r\n  }\r\n}; \r\n","size_bytes":2737},"commands/couponCreate.js":{"content":"import { EmbedBuilder, SlashCommandBuilder } from 'discord.js';\n\nexport default {\n  data: new SlashCommandBuilder()\n    .setName('coupon-create')\n    .setDescription('Add a coupon.')\n    .addStringOption((option) => option.setName('code').setDescription('Coupon code').setRequired(true))\n    .addBooleanOption((option) => option.setName('global').setDescription('Is the coupon global?').setRequired(true))\n    .addNumberOption((option) => option.setName('discount').setDescription('Discount amount').setRequired(true))\n    .addStringOption((option) =>\n      option\n        .setName('type')\n        .setDescription('Discount type: percentage or fixed')\n        .setRequired(true)\n        .addChoices({ name: 'Percentage', value: 'percentage' }, { name: 'Fixed', value: 'fixed' })\n    )\n    .addNumberOption((option) =>\n      option.setName('max_uses').setDescription('Maximum uses for the coupon').setRequired(true)\n    )\n    .addStringOption((option) =>\n      option.setName('expiration_date').setDescription('Expiration date (e.g., 2024-09-25T12:35:22)').setRequired(true)\n    )\n    .addStringOption((option) =>\n      option.setName('allowed_emails').setDescription('Allowed emails (comma-separated)').setRequired(false)\n    )\n    .addStringOption((option) =>\n      option.setName('products').setDescription('Applicable product IDs (comma-separated)').setRequired(false)\n    ),\n\n  onlyWhitelisted: true,\n  requiredRole: 'admin',\n\n  async execute(interaction, api) {\n    const code = interaction.options.getString('code');\n    const global = interaction.options.getBoolean('global');\n    const discount = interaction.options.getNumber('discount');\n    const type = interaction.options.getString('type');\n    const maxUses = interaction.options.getNumber('max_uses');\n    const expirationDate = interaction.options.getString('expiration_date');\n    const allowedEmails = interaction.options.getString('allowed_emails')?.split(',') || [];\n    let products = interaction.options.getString('products')?.split(',') || [];\n\n    // Remove products if the coupon is global\n    if (global) {\n      products = [];\n    }\n\n    const couponData = {\n      code,\n      global,\n      discount,\n      type,\n      max_uses: maxUses,\n      expiration_date: expirationDate,\n      allowed_emails: allowedEmails,\n      products\n    };\n\n    try {\n      await api.post(`shops/${api.shopId}/coupons`, couponData);\n\n      const embed = new EmbedBuilder()\n        .setTitle('Coupon Created')\n        .setDescription(`Coupon \\`${code}\\` has been successfully created.`)\n        .setColor('#6571ff')\n        .addFields(\n          { name: 'Discount', value: `${discount} (${type})`, inline: true },\n          { name: 'Global', value: global ? 'Yes' : 'No', inline: true },\n          { name: 'Max Uses', value: maxUses?.toString() ?? 'âˆž', inline: true },\n          { name: 'Expires On', value: expirationDate, inline: true }\n        );\n\n      return interaction.reply({ embeds: [embed] });\n    } catch (error) {\n      console.error(error);\n      return interaction.reply({ content: 'There was an error creating the coupon.', ephemeral: true });\n    }\n  }\n};\n","size_bytes":3129},"commands/claim.js":{"content":"import { SlashCommandBuilder } from 'discord.js';\r\nimport { readFileSync, writeFileSync, existsSync } from 'fs';\r\nimport { join } from 'path';\r\nimport { config } from '../utils/config.js';\r\n\r\n// Initialize claims data storage\r\nconst claimsFilePath = join(process.cwd(), 'claims.json');\r\nlet claimsData = {};\r\n\r\nif (existsSync(claimsFilePath)) {\r\n  claimsData = JSON.parse(readFileSync(claimsFilePath, 'utf-8'));\r\n} else {\r\n  writeFileSync(claimsFilePath, JSON.stringify(claimsData));\r\n}\r\n\r\nexport default {\r\n  data: new SlashCommandBuilder()\r\n    .setName('claim')\r\n    .setDescription('Claim a Customer role with a shop invoice')\r\n    .addStringOption(option => \r\n      option.setName('invoice_id')\r\n        .setDescription('Invoice ID')\r\n        .setRequired(true))\r\n    .addStringOption(option => \r\n      option.setName('email')\r\n        .setDescription('The email associated with the invoice')\r\n        .setRequired(true)),\r\n\r\n  async execute(interaction, api) {\r\n    const invoiceIdInput = interaction.options.getString('invoice_id');\r\n    const userEmail = interaction.options.getString('email');\r\n\r\n    // Process the invoice ID\r\n    let invoiceId = invoiceIdInput.includes('-') ? \r\n      invoiceIdInput.split('-').pop() : \r\n      invoiceIdInput;\r\n    invoiceId = invoiceId.replace(/^0+/, ''); // Trim leading zeros\r\n\r\n    // Check if already claimed\r\n    if (claimsData[invoiceId]) {\r\n      await interaction.reply({ \r\n        content: `Customer role has already been claimed via invoice ${invoiceId}.`, \r\n        ephemeral: true \r\n      });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const invoiceData = await api.get(`shops/${api.shopId}/invoices/${invoiceId}`);\r\n\r\n      // Verify email matches\r\n      if (invoiceData.email !== userEmail) {\r\n        await interaction.reply({ \r\n          content: 'The provided email does not match the invoice\\'s email.', \r\n          ephemeral: true \r\n        });\r\n        return;\r\n      }\r\n\r\n      // Check if paid\r\n      if (invoiceData.completed_at) {\r\n        // Add role if configured\r\n        if (config.BOT_CUSTOMER_ROLE_ID) {\r\n          const customerRole = interaction.guild.roles.cache.get(config.BOT_CUSTOMER_ROLE_ID);\r\n          if (customerRole) {\r\n            await interaction.member.roles.add(customerRole);\r\n          }\r\n        }\r\n\r\n        // Save claim\r\n        claimsData[invoiceId] = interaction.user.id;\r\n        writeFileSync(claimsFilePath, JSON.stringify(claimsData, null, 2));\r\n\r\n        await interaction.reply({ \r\n          content: `Customer role claimed successfully via invoice ${invoiceId}!`, \r\n          ephemeral: true \r\n        });\r\n      } else {\r\n        await interaction.reply({ \r\n          content: `Invoice ${invoiceId} has not been paid yet.`, \r\n          ephemeral: true \r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('Error claiming role:', error);\r\n      await interaction.reply({ \r\n        content: 'An error occurred while processing your request.', \r\n        ephemeral: true \r\n      });\r\n    }\r\n  }\r\n};","size_bytes":3015},"utils/formatPrice.js":{"content":"export function formatPrice(price, currency) {\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: currency,\n    currencyDisplay: 'symbol'\n  }).format(price);\n}\n","size_bytes":188},"commands/invoiceProcess.js":{"content":"import { SlashCommandBuilder } from 'discord.js';\n\nexport default {\n  data: new SlashCommandBuilder()\n    .setName('invoice-process')\n    .setDescription('process a invoice.')\n    .addStringOption((option) => option.setName('id').setDescription('The invoice ID to search for').setRequired(true)),\n\n  onlyWhitelisted: true,\n  requiredRole: 'admin',\n\n  async execute(interaction, api) {\n    const shopId = api.shopId;\n    const id = interaction.options.getString('id');\n\n    let invoiceId = id;\n\n    if (invoiceId.includes('-')) {\n      invoiceId = Number(id.split('-')[1]);\n    }\n\n    try {\n      await api.get(`shops/${shopId}/invoices/${invoiceId}/process`);\n      await interaction.reply({ content: 'Invoice processed successfully.', ephemeral: true });\n    } catch (error) {\n      if (error.response) {\n        if (error.response.status === 404) {\n          await interaction.reply({ content: `No invoice found with the id: ${id}`, ephemeral: true });\n          return;\n        }\n\n        if (error.response.status === 400) {\n          await interaction.reply({ content: 'Invoice already processed or failed to process.', ephemeral: true });\n          return;\n        }\n      }\n\n      console.error('Error processing invoice:', error);\n      await interaction.reply({ content: 'Failed to process invoice.', ephemeral: true });\n    }\n  }\n};\n","size_bytes":1343},"replit.md":{"content":"# SellAuth Discord Bot\n\n## Overview\n\nThis is a Discord bot that integrates with the SellAuth e-commerce platform, allowing shop owners to manage their SellAuth stores directly through Discord commands. The bot provides administrative functions including product management, order processing, coupon management, invoice handling, and customer role assignment.\n\nThe application uses Discord.js v14 to interface with Discord's API and communicates with SellAuth's REST API to perform shop management operations. It implements a slash command system with role-based access control and whitelist permissions.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Command System Architecture\n\n**Problem**: Need a scalable way to register and handle Discord slash commands with proper permission controls.\n\n**Solution**: Dynamic command loading system that reads command files from a `/commands` directory and automatically registers them as Discord slash commands.\n\n**Implementation Details**:\n- Commands are individual ES6 modules that export a configuration object with `data` (SlashCommandBuilder), `execute` function, and optional permission flags\n- The `Bot` class loads all command files at startup, builds a command collection, and registers them with Discord's REST API\n- Commands can specify `onlyWhitelisted: true` and `requiredRole` ('admin' or 'staff') for access control\n- Cooldown system prevents command spam\n\n**Pros**: Easy to add new commands, clean separation of concerns, maintainable structure\n**Cons**: All commands load at startup (no lazy loading)\n\n### Permission & Access Control\n\n**Problem**: Need granular control over who can execute administrative commands.\n\n**Solution**: Multi-tier permission system combining Discord roles and user ID whitelists.\n\n**Implementation Details**:\n- Three permission levels: Admin (full access), Staff (limited access), and Whitelist (legacy fallback)\n- `checkUserIdWhitelist` utility validates permissions before command execution\n- Commands marked with `onlyWhitelisted: true` require either admin role, staff role (if command allows), or presence in user ID whitelist\n- Configuration supports `BOT_ADMIN_ROLE_ID`, `BOT_STAFF_ROLE_ID`, and `BOT_USER_ID_WHITELIST`\n\n**Rationale**: Provides flexibility for different organizational structures while maintaining security\n\n### Claims System\n\n**Problem**: Need to prevent duplicate customer role assignments and track which invoices have been claimed.\n\n**Solution**: File-based persistence using `claims.json` to store claimed invoice IDs.\n\n**Implementation Details**:\n- Claims data stored as JSON object mapping invoice IDs to claim status\n- Read at startup and written when new claims are processed\n- The `claim` command validates invoice ownership via email match before assigning customer role\n- Prevents re-claiming already used invoices\n\n**Alternative Considered**: Database storage\n**Pros of Current Approach**: Simple, no database dependency, suitable for small-scale usage\n**Cons**: Not suitable for high-concurrency scenarios, file I/O blocking, data loss risk without backups\n\n### API Communication Layer\n\n**Problem**: Need consistent interface for making authenticated HTTP requests to SellAuth API.\n\n**Solution**: `Api` class that encapsulates all HTTP communication with the SellAuth platform.\n\n**Implementation Details**:\n- Centralized API client with base URL and authentication headers\n- Methods for GET, POST, PUT, and DELETE operations (DELETE implementation appears incomplete in provided code)\n- Uses `node-fetch` for HTTP requests\n- API credentials (API key and shop ID) loaded from environment configuration\n- Error handling throws objects with response details\n\n**Pros**: Single source of truth for API communication, easy to mock for testing\n**Cons**: Limited error handling, no retry logic, incomplete DELETE method implementation\n\n### Event-Driven Architecture\n\n**Problem**: Need to respond to Discord interactions and lifecycle events.\n\n**Solution**: Event listener pattern using Discord.js event emitters.\n\n**Implementation Details**:\n- Bot class sets up event listeners for `ready`, `warn`, `error`, and `interactionCreate`\n- `onInteractionCreate` method handles slash command execution with permission checks\n- Commands are executed via their exported `execute` function with interaction and API client passed as parameters\n\n**Rationale**: Aligns with Discord.js framework conventions, enables reactive behavior\n\n## External Dependencies\n\n### Discord API Integration\n- **Library**: discord.js v14.15.3\n- **Purpose**: Discord bot framework for creating slash commands, managing guild interactions, and handling events\n- **Key Features Used**: SlashCommandBuilder, Client with Gateway intents, REST API for command registration, EmbedBuilder for rich messages, ActionRowBuilder and ButtonBuilder for interactive components\n- **Authentication**: Bot token (`BOT_TOKEN`) required in environment configuration\n\n### SellAuth REST API\n- **Base URL**: `https://api.sellauth.com/v1/`\n- **Purpose**: E-commerce platform API for managing shop products, invoices, coupons, orders, and statistics\n- **Authentication**: Bearer token authentication using shop API key (`SA_API_KEY`)\n- **Key Endpoints Used**:\n  - `/shops/{shopId}/products/*` - Product management and deliverables\n  - `/shops/{shopId}/invoices/*` - Invoice viewing and processing\n  - `/shops/{shopId}/coupons/*` - Coupon CRUD operations\n  - `/shops/{shopId}/payouts/balances` - Cryptocurrency balance viewing\n  - `/shops/{shopId}/stats` - Shop statistics\n- **Required Configuration**: `SA_API_KEY` and `SA_SHOP_ID`\n\n### Environment Configuration\n- **Library**: dotenv v16.4.5\n- **Purpose**: Load environment variables from `.env` file\n- **Required Variables**:\n  - `BOT_TOKEN` - Discord bot authentication token\n  - `BOT_GUILD_ID` - Discord server ID for command registration\n  - `BOT_USER_ID_WHITELIST` - Comma-separated user IDs for legacy permission system\n  - `BOT_CUSTOMER_ROLE_ID` - Role assigned to customers using claim command\n  - `BOT_STAFF_ROLE_ID` - Role ID for staff-level permissions\n  - `BOT_ADMIN_ROLE_ID` - Role ID for admin-level permissions\n  - `SA_API_KEY` - SellAuth API authentication key\n  - `SA_SHOP_ID` - SellAuth shop identifier\n\n### HTTP Client\n- **Library**: node-fetch v3.3.2\n- **Purpose**: Make HTTP requests to SellAuth API (required because Node.js native fetch wasn't available in target Node version)\n- **Usage**: All API requests in `Api` class\n\n### File System\n- **Module**: Node.js built-in `fs` module\n- **Purpose**: Read command files dynamically, persist claims data to JSON file\n- **Usage**: Command loading, claims.json read/write operations\n\n### Development Tools\n- **nodemon** v2.0.22 - Auto-restart during development\n- **prettier** v3.3.1 - Code formatting","size_bytes":6839},"commands/replace.js":{"content":"import { SlashCommandBuilder } from 'discord.js';\nimport { readFileSync, writeFileSync, existsSync } from 'fs';\nimport { join } from 'path';\n\nconst historyFilePath = join(process.cwd(), 'replaceHistory.json');\nconst variantsCachePath = join(process.cwd(), 'variantsCache.json');\nlet historyData = [];\nlet variantsCache = {};\n\nif (existsSync(historyFilePath)) {\n  historyData = JSON.parse(readFileSync(historyFilePath, 'utf-8'));\n}\n\nif (existsSync(variantsCachePath)) {\n  variantsCache = JSON.parse(readFileSync(variantsCachePath, 'utf-8'));\n}\n\nfunction saveHistory() {\n  writeFileSync(historyFilePath, JSON.stringify(historyData, null, 2));\n}\n\nfunction saveVariantsCache() {\n  writeFileSync(variantsCachePath, JSON.stringify(variantsCache, null, 2));\n}\n\nfunction addToHistory(productId, productName, removedItems, variantId = null) {\n  historyData.push({\n    timestamp: new Date().toISOString(),\n    productId,\n    productName,\n    variantId,\n    removedItems,\n    count: removedItems.length\n  });\n  saveHistory();\n}\n\nasync function getVariantStock(api, productId, variantId) {\n  try {\n    const deliverablesData = await api.get(\n      `shops/${api.shopId}/products/${productId}/deliverables/${variantId}`\n    );\n    \n    let items = [];\n    if (typeof deliverablesData === 'string') {\n      items = deliverablesData.split('\\n').filter(item => item.trim());\n    } else if (deliverablesData.deliverables) {\n      items = deliverablesData.deliverables.split('\\n').filter(item => item.trim());\n    }\n    \n    return items;\n  } catch (e) {\n    return [];\n  }\n}\n\nasync function getProductVariants(api, productId) {\n  const cacheKey = `product_${productId}`;\n  \n  // Check cache (expires after 10 minutes)\n  if (variantsCache[cacheKey]) {\n    const cached = variantsCache[cacheKey];\n    if (Date.now() - cached.timestamp < 10 * 60 * 1000) {\n      return cached.variants;\n    }\n  }\n\n  const variants = [];\n  \n  // Test ID ranges with exponential backoff\n  const idsToTest = [\n    // First test small IDs\n    ...Array.from({length: 30}, (_, i) => i),\n    // Then test larger ID ranges (SellAuth uses large IDs like 268289)\n    100, 200, 500, 1000, 5000, 10000, 50000, 100000, 200000, 250000, 260000, 265000, 268289, 270000\n  ];\n\n  // Test all IDs in parallel\n  const promises = idsToTest.map(id => \n    getVariantStock(api, productId, id.toString()).then(items => ({\n      id: id.toString(),\n      stock: items.length\n    }))\n  );\n\n  const results = await Promise.all(promises);\n  \n  for (const result of results) {\n    if (result.stock > 0) {\n      variants.push({\n        id: result.id,\n        stock: result.stock\n      });\n    }\n  }\n\n  // Cache the results\n  variantsCache[cacheKey] = {\n    variants,\n    timestamp: Date.now()\n  };\n  saveVariantsCache();\n\n  return variants;\n}\n\nexport default {\n  data: new SlashCommandBuilder()\n    .setName('replace')\n    .setDescription('Take items from stock and send them')\n    .addStringOption(option => \n      option.setName('product')\n        .setDescription('Product name or ID')\n        .setRequired(true)\n        .setAutocomplete(true))\n    .addIntegerOption(option => \n      option.setName('quantity')\n        .setDescription('Number of items to take from stock')\n        .setRequired(true)\n        .setMinValue(1))\n    .addStringOption(option => \n      option.setName('variant')\n        .setDescription('Select variant ID')\n        .setRequired(false)\n        .setAutocomplete(true)),\n\n  onlyWhitelisted: true,\n  requiredRole: 'staff',\n\n  async execute(interaction, api) {\n    const productInput = interaction.options.getString('product');\n    const quantity = interaction.options.getInteger('quantity');\n    const variantInput = interaction.options.getString('variant') || '0';\n\n    try {\n      await interaction.deferReply({ ephemeral: true });\n\n      const products = await api.get(`shops/${api.shopId}/products`);\n      const productList = Array.isArray(products) ? products : (products?.data || []);\n      \n      let product = productList.find(p => \n        p.id.toString() === productInput || \n        p.name.toLowerCase() === productInput.toLowerCase()\n      );\n\n      if (!product) {\n        await interaction.editReply({ \n          content: `âŒ Producto no encontrado: ${productInput}` \n        });\n        return;\n      }\n\n      const deliverablesArray = await getVariantStock(api, product.id, variantInput);\n\n      if (deliverablesArray.length === 0) {\n        await interaction.editReply({ \n          content: `âŒ No hay stock en variante **${variantInput}** para **${product.name}**\\n\\n` +\n                   `ðŸ’¡ Verifica el Variant ID en: https://dash.sellauth.com/products/edit/${product.id}`\n        });\n        return;\n      }\n\n      if (deliverablesArray.length < quantity) {\n        await interaction.editReply({ \n          content: `âŒ Stock insuficiente en variante **${variantInput}**\\n\\n` +\n                   `â€¢ Stock disponible: ${deliverablesArray.length}\\n` +\n                   `â€¢ Cantidad solicitada: ${quantity}`\n        });\n        return;\n      }\n\n      const removedItems = deliverablesArray.splice(0, quantity);\n      const newDeliverablesString = deliverablesArray.join('\\n');\n\n      try {\n        await api.put(\n          `shops/${api.shopId}/products/${product.id}/deliverables/overwrite/${variantInput}`,\n          { deliverables: newDeliverablesString }\n        );\n      } catch (error) {\n        console.error('API Error:', error);\n        await interaction.editReply({ \n          content: `âŒ Error actualizando stock: ${error.message || 'Error desconocido'}`\n        });\n        return;\n      }\n\n      addToHistory(product.id, product.name, removedItems, variantInput);\n\n      await interaction.editReply({ \n        content: `âœ… Items removidos de **${product.name}** (Variante: ${variantInput})!\\n\\n` +\n                 `ðŸ“¤ Enviados (${quantity}):\\n\\`\\`\\`${removedItems.join('\\n')}\\`\\`\\`\\n` +\n                 `ðŸ“¦ Stock restante: ${deliverablesArray.length}`\n      });\n    } catch (error) {\n      console.error('Error:', error);\n      await interaction.editReply({ \n        content: `âŒ Error: ${error.message || 'Error desconocido'}` \n      });\n    }\n  },\n\n  async autocomplete(interaction, api) {\n    const focusedOption = interaction.options.getFocused(true);\n    \n    if (focusedOption.name === 'product') {\n      try {\n        const products = await api.get(`shops/${api.shopId}/products`);\n        const productList = Array.isArray(products) ? products : (products?.data || []);\n        \n        const filtered = productList\n          .filter(product => \n            product.name.toLowerCase().includes(focusedOption.value.toLowerCase()) ||\n            product.id.toString().includes(focusedOption.value)\n          )\n          .slice(0, 25)\n          .map(product => ({\n            name: `${product.name}`,\n            value: product.id.toString()\n          }));\n\n        await interaction.respond(filtered).catch(() => {});\n      } catch (error) {\n        await interaction.respond([]).catch(() => {});\n      }\n    } else if (focusedOption.name === 'variant') {\n      try {\n        const productInput = interaction.options.getString('product');\n        if (!productInput) {\n          await interaction.respond([]).catch(() => {});\n          return;\n        }\n\n        const products = await api.get(`shops/${api.shopId}/products`);\n        const productList = Array.isArray(products) ? products : (products?.data || []);\n        \n        let product = productList.find(p => \n          p.id.toString() === productInput\n        );\n\n        if (!product) {\n          await interaction.respond([]).catch(() => {});\n          return;\n        }\n\n        // Get variants (cached if available)\n        const variants = await getProductVariants(api, product.id);\n        \n        const filtered = variants\n          .filter(v => v.id.includes(focusedOption.value))\n          .slice(0, 25)\n          .map(v => ({\n            name: `ID ${v.id} (${v.stock} items)`,\n            value: v.id\n          }));\n\n        await interaction.respond(filtered).catch(() => {});\n      } catch (error) {\n        await interaction.respond([]).catch(() => {});\n      }\n    }\n  }\n};\n","size_bytes":8163},"commands/unreplace.js":{"content":"import { SlashCommandBuilder } from 'discord.js';\nimport { readFileSync, writeFileSync, existsSync } from 'fs';\nimport { join } from 'path';\n\nconst historyFilePath = join(process.cwd(), 'replaceHistory.json');\nlet historyData = [];\n\nif (existsSync(historyFilePath)) {\n  historyData = JSON.parse(readFileSync(historyFilePath, 'utf-8'));\n}\n\nfunction saveHistory() {\n  writeFileSync(historyFilePath, JSON.stringify(historyData, null, 2));\n}\n\nexport default {\n  data: new SlashCommandBuilder()\n    .setName('unreplace')\n    .setDescription('Restore the last item(s) removed from stock')\n    .addIntegerOption(option => \n      option.setName('count')\n        .setDescription('Number of recent removals to restore (default: 1)')\n        .setRequired(false)\n        .setMinValue(1)),\n\n  onlyWhitelisted: true,\n  requiredRole: 'staff',\n\n  async execute(interaction, api) {\n    const count = interaction.options.getInteger('count') || 1;\n\n    try {\n      await interaction.deferReply({ ephemeral: true });\n\n      if (existsSync(historyFilePath)) {\n        historyData = JSON.parse(readFileSync(historyFilePath, 'utf-8'));\n      }\n\n      if (historyData.length === 0) {\n        await interaction.editReply({ \n          content: `âŒ No se encontrÃ³ historial de reemplazos. Nada que restaurar.` \n        });\n        return;\n      }\n\n      if (count > historyData.length) {\n        await interaction.editReply({ \n          content: `âŒ Solo hay ${historyData.length} reemplazo(s) en el historial. No se pueden restaurar ${count}.` \n        });\n        return;\n      }\n\n      const toRestore = historyData.splice(-count);\n      const restoredInfo = [];\n      let totalItemsRestored = 0;\n\n      for (const replacement of toRestore) {\n        try {\n          const productId = replacement.productId;\n          const productName = replacement.productName;\n          const removedItems = replacement.removedItems;\n          const variantId = replacement.variantId || '0';\n\n          const endpoint = `shops/${api.shopId}/products/${productId}/deliverables/${variantId}`;\n\n          let deliverablesData = await api.get(endpoint);\n          let deliverablesArray = [];\n          \n          if (typeof deliverablesData === 'string') {\n            deliverablesArray = deliverablesData.split('\\n').filter(item => item.trim());\n          } else if (deliverablesData.deliverables) {\n            deliverablesArray = deliverablesData.deliverables.split('\\n').filter(item => item.trim());\n          }\n\n          const restoredArray = [...removedItems, ...deliverablesArray];\n          const newDeliverablesString = restoredArray.join('\\n');\n          \n          await api.put(\n            `shops/${api.shopId}/products/${productId}/deliverables/overwrite/${variantId}`,\n            { deliverables: newDeliverablesString }\n          );\n\n          restoredInfo.push({\n            product: productName,\n            variant: variantId,\n            count: removedItems.length\n          });\n          totalItemsRestored += removedItems.length;\n        } catch (error) {\n          console.error(`[UNREPLACE] Error:`, error);\n          await interaction.editReply({ \n            content: `âŒ Error restaurando: ${error.message || 'Error desconocido'}` \n          });\n          return;\n        }\n      }\n\n      saveHistory();\n\n      let responseMsg = `âœ… Restaurados ${count} reemplazo(s)!\\n\\n`;\n      restoredInfo.forEach((info, idx) => {\n        responseMsg += `${idx + 1}. **${info.product}** (Var: ${info.variant}) - ${info.count} item(s)\\n`;\n      });\n      responseMsg += `\\nðŸ“¦ Total items restaurados: ${totalItemsRestored}`;\n\n      await interaction.editReply({ content: responseMsg });\n    } catch (error) {\n      console.error('[UNREPLACE] Error:', error);\n      await interaction.editReply({ \n        content: `âŒ Error: ${error.message || 'Error desconocido'}` \n      });\n    }\n  }\n};\n","size_bytes":3869}},"version":2}